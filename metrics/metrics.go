package metrics

import (
	"fmt"
	"net/http"
	"sync"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

// Metrics is a package-level singleton to track the state
// of all metrics generated by the process
type Metrics struct {
	namespace string
}

var mtx *Metrics

// MetricsRegistry proves a per-module api for creating
// and updating metrics
type MetricsRegistry struct {
	subsystem  string
	counters   map[string]prometheus.Counter
	gauges     map[string]prometheus.Gauge
	histograms map[string]prometheus.Histogram
	lock       sync.RWMutex
}

// Init intializes the metrics package with the given namespace string.
// This should only be called once per process.
func Init(namespace string) (http.Handler, error) {
	if mtx != nil {
		return nil, fmt.Errorf("metrics.Init() should only be called once")
	}
	mtx = &Metrics{
		namespace,
	}

	return promhttp.Handler(), nil
}

// NewMetricsRegistry creates a new MetricsRegistry for a given module
// to use.
func NewMetricsRegistry(subsystem string) *MetricsRegistry {
	return &MetricsRegistry{
		subsystem:  subsystem,
		counters:   make(map[string]prometheus.Counter),
		gauges:     make(map[string]prometheus.Gauge),
		histograms: make(map[string]prometheus.Histogram),
	}
}

// Counter creates or fetches a prometheus Counter from the metrics
// registry and returns it.
func (m *MetricsRegistry) Counter(name string) prometheus.Counter {
	m.lock.RLock()
	counter, ok := m.counters[name]
	m.lock.RUnlock()
	if !ok {
		counter = promauto.NewCounter(prometheus.CounterOpts{
			Namespace: mtx.namespace,
			Subsystem: m.subsystem,
			Name:      name,
		})

		m.lock.Lock()
		m.counters[name] = counter
		m.lock.Unlock()
	}

	return counter
}

// Gauge creates or fetches a prometheus Gauge from the metrics
// registry and returns it.
func (m *MetricsRegistry) Gauge(name string) prometheus.Gauge {
	m.lock.RLock()
	gauge, ok := m.gauges[name]
	m.lock.RUnlock()
	if !ok {
		gauge = promauto.NewGauge(prometheus.GaugeOpts{
			Namespace: mtx.namespace,
			Subsystem: m.subsystem,
			Name:      name,
		})

		m.lock.Lock()
		m.gauges[name] = gauge
		m.lock.Unlock()
	}

	return gauge
}

func (m *MetricsRegistry) GaugeFunc(name string, handler func() float64) {
	_ = promauto.NewGaugeFunc(prometheus.GaugeOpts{
		Namespace: mtx.namespace,
		Subsystem: m.subsystem,
		Name:      name,
	}, handler)
}

// Histogram creates or fetches a prometheus Histogram from the metrics
// registry and returns it.
func (m *MetricsRegistry) Histogram(name string) prometheus.Histogram {
	m.lock.RLock()
	histogram, ok := m.histograms[name]
	m.lock.RUnlock()
	if !ok {
		histogram = promauto.NewHistogram(prometheus.HistogramOpts{
			Namespace: mtx.namespace,
			Subsystem: m.subsystem,
			Name:      name,
		})

		m.lock.Lock()
		m.histograms[name] = histogram
		m.lock.Unlock()
	}

	return histogram
}
